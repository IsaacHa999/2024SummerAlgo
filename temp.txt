// boj 1634 완전 이진트리
/*
 입력
4
4 2 1 3 6 7 5 8
2 7 4 8 3 1 6 5

출력
4
 */

#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
using namespace std;

// 두 노드의 인덱스를 기반으로 완전 이진 트리에서의 거리를 계산하는 함수,
int getDistance(int idx1, int idx2) {   // idx1, idx2: 노드의 인덱스, ex) 1, 2, 3, 4, 5, 6, 7, 8
    int distance = 0;
    while (idx1 != idx2) {
        if (idx1 > idx2) idx1 /= 2;  // 부모 노드로 이동
        else idx2 /= 2;  // 부모 노드로 이동
        distance++;  // 경로 상의 노드 수 증가
    }
    return distance*2;  // 총 거리 반환
}

// getDidtance 함수 테스트: 1, 2, 3, 4, 5, 6, 7, 8 인덱스를 가지는 노드의 거리를 계산
void testGetDistance() {
    for (int i = 1; i <= 8; ++i) {
        for (int j = i + 1; j <= 8; ++j) {
            cout << "getDistance(" << i << ", " << j << ") = " << getDistance(i, j) << endl;
        }
    }
}

int main() {
    testGetDistance();
    int k;
    cin >> k;
    int n = (1 << k-1);  // 단말 노드의 수 계산 (2^k), ex) k=3이면 n=8

    vector<int> leaves1(n), leaves2(n); // T1, T2 트리의 단말 노드 레이블을 저장
    unordered_map<int, int> posInT2;  // T2 트리에서 각 레이블의 위치를 저장, key: 레이블, value: 위치,

    for (int i = 0; i < n; ++i) cin >> leaves1[i];  // T1 트리의 단말 노드 레이블 입력
    for (int i = 0; i < n; ++i) {   // T2 트리의 단말 노드 레이블 입력
        cin >> leaves2[i];
        posInT2[leaves2[i]] = i;  // 레이블의 위치를 posInT2에 저장,(인덱스 반환)
    }

    // debug leaves1, leaves2, posInT2 출력
    cout << "leaves1: ";
    for (int i = 0; i < n; ++i) cout << leaves1[i] << " ";
    cout << endl;

    cout << "leaves2: ";
    for (int i = 0; i < n; ++i) cout << leaves2[i] << " ";
    cout << endl;

    cout << "posInT2: ";
    for (const auto& pair : posInT2) cout << pair.first << " -> " << pair.second << ", ";
    cout << endl;

    // 거리 해쉬를 저장하는 해쉬맵, key는 거리 쌍, value는 그 거리를 가지는 레이블들의 집합
    unordered_map<string, unordered_set<int>> distanceHashes;   // key: 거리 쌍, value: 그 거리를 가지는 레이블들의 집합,

    // T1의 모든 레이블 쌍에 대한 거리를 계산하고 해시맵에 저장
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int dist1 = getDistance(i, j);  // T1에서의 거리 계산, ex) getDistance(0, 1) = 2, 각각 값은 4, 2
            int dist2 = getDistance(posInT2[leaves1[i]], posInT2[leaves1[j]]);  // T2에서의 거리 계산, getDistance(
            string key = to_string(dist1) + "," + to_string(dist2);
            distanceHashes[key].insert(leaves1[i]);
            distanceHashes[key].insert(leaves1[j]);
        }
    }

    // debug distanceHashes 출력
    cout << "distanceHashes: ";
    for (const auto& pair : distanceHashes) {
        cout << pair.first << " -> ";
        for (const auto& label : pair.second) cout << label << " ";
        cout << ", ";
    }
    cout << endl;

    // 최대 집합의 크기를 찾음
    int maxSize = 0;
    for (const auto& pair : distanceHashes) {
        maxSize = max(maxSize, static_cast<int>(pair.second.size()));
    }

    cout << maxSize << endl;

    return 0;
}
